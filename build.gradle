plugins {
    id 'java'
    id 'idea'
//    id 'org.springframework.boot' version '3.1.1'
    id 'io.spring.dependency-management' version '1.1.0'
    id 'com.avast.gradle.docker-compose' version '0.16.12'
}

ext {
    set("PROJECT_VERSION", "0.2.8")
}

//version = '0.0.1-SNAPSHOT'
apply plugin: 'docker-compose'

java {
    sourceCompatibility = '17'
}

idea {
    project {
        languageLevel = 17
    }
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

allprojects {

    version = "${PROJECT_VERSION}-SNAPSHOT"

    repositories {
        mavenCentral()
    }

    ext {
        set('springCloudVersion', "2022.0.3")
    }

    dependencyManagement {
        imports {
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
        }
    }


    tasks.withType(JavaCompile) {
        options.with {
            encoding = 'UTF-8'
        }
    }

}

tasks.named('test') {
    useJUnitPlatform()
}

// build compose images via gradle
dockerCompose {
    useComposeFiles = ['docker-compose.yaml'] // like 'docker-compose -f <file>'; default is empty
    forceRecreate = false
    // pass '--force-recreate' and '--renew-anon-volumes' when calling 'docker-compose up' when set to 'true`
    noRecreate = false // pass '--no-recreate' when calling 'docker-compose up' when set to 'true`
    buildBeforeUp = true
    // performs 'docker-compose build' before calling the 'up' command; default is true
    buildBeforePull = true
    // performs 'docker-compose build' before calling the 'pull' command; default is true
    ignorePullFailure = false
    // when set to true, pass '--ignore-pull-failure' to 'docker-compose pull'
    ignorePushFailure = false
    // when set to true, pass '--ignore-push-failure' to 'docker-compose push'
    pushServices = ["kafka-message-producer", "kafka-message-consumer", "subscriptions-holder-service", "spring-eureka-registry", "spring-gateway", "t-coubs-initiator", "telegram-bot", "coub-tags-searcher"]
    // which services should be pushed, if not defined then upon `composePush` task all defined services in compose file will be pushed (default behaviour)
    buildAdditionalArgs = ['--force-rm']
    pullAdditionalArgs = ['--ignore-pull-failures']
    upAdditionalArgs = ['--no-deps']
    downAdditionalArgs = ['--some-switch']
    composeAdditionalArgs = [ '--verbose', "--log-level", "DEBUG"]
    // for adding more [options] in docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]

    waitForTcpPorts = true
    // turns on/off the waiting for exposed TCP ports opening; default is true
    waitForTcpPortsTimeout = java.time.Duration.ofMinutes(15)
    // how long to wait until all exposed TCP become open; default is 15 minutes
    waitAfterTcpProbeFailure = java.time.Duration.ofSeconds(1)
    // how long to sleep before next attempt to check if a TCP is open; default is 1 second
    tcpPortsToIgnoreWhenWaiting = [1234]
    // list of TCP ports what will be ignored when waiting for exposed TCP ports opening; default: empty list
    waitForHealthyStateTimeout = java.time.Duration.ofMinutes(15)
    // how long to wait until a container becomes healthy; default is 15 minutes
    waitAfterHealthyStateProbeFailure = java.time.Duration.ofSeconds(5)
    // how long to sleep before next attempt to check healthy status; default is 5 seconds
    checkContainersRunning = true
    // turns on/off checking if container is running or restarting (during waiting for open TCP port and healthy state); default is true

    captureContainersOutput = false
    // if true, prints output of all containers to Gradle output - very useful for debugging; default is false
    captureContainersOutputToFile = project.file('./containers.log')
    // sends output of all containers to a log file
    captureContainersOutputToFiles = project.file('./logs/')
    // sends output of all services to a dedicated log file in the directory specified, e.g. 'web.log' for service named 'log'
    composeLogToFile = project.file('build/my-logs.log')
    // redirect output of composeUp and composeDown tasks to this file; default is null (ouput is not redirected)
    containerLogToDir = project.file('build/logs')
    // directory where composeLogs task stores output of the containers; default: build/containers-logs
    includeDependencies = false
    // calculates services dependencies of startedServices and includes those when gathering logs or removing containers; default is false

    stopContainers = true
    // doesn't call `docker-compose down` if set to false - see below the paragraph about reconnecting; default is true
    removeContainers = true // default is true
    retainContainersOnStartupFailure = false
    // if set to true, skips running ComposeDownForced task when ComposeUp fails - useful for troubleshooting; default is false
    removeImages = com.avast.gradle.dockercompose.RemoveImages.None
    // Other accepted values are All and Local
    removeVolumes = true // default is true
    removeOrphans = false
    // removes containers for services not defined in the Compose file; default is false

    projectName = null
    // allow to set custom docker-compose project name (defaults to a stable name derived from absolute path of the project and nested settings name), set to null to Docker Compose default (directory name)
    projectNamePrefix = null
    // allow to set custom prefix of docker-compose project name, the final project name has nested configuration name appended
//    executable = '/path/to/docker-compose'
//    // allow to set the path of the docker-compose executable (useful if not present in PATH)
//    dockerExecutable = '/path/to/docker'
//    // allow to set the path of the docker executable (useful if not present in PATH)
    dockerComposeWorkingDirectory = project.file('.')
    dockerComposeStopTimeout = java.time.Duration.ofSeconds(20)
    // time before docker-compose sends SIGTERM to the running containers after the composeDown task has been started
    environment.put 'JAR_VERSION', project.version
    // environment variables to be used when calling 'docker-compose', e.g. for substitution in compose file
}

tasks.register('printVersion') {
    // any code that goes here is part of configuring the task
    // this code will always get run, even if the task is not executed
    doLast { // add a task action
        // any code that goes here is part of executing the task
        // this code will only get run if and when the task gets executed
        println project.version
    }
}



